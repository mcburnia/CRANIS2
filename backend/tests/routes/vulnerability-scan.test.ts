/**
 * Vulnerability / Risk Findings Route Tests — /api/risk-findings
 *
 * Tests: overview (all products), per-product findings, cross-org isolation
 *
 * API response format notes:
 * - GET /api/risk-findings/overview returns { products: [...] }
 *   Each product has: id, name, craCategory, lastScan, findings: { critical, high, medium, low, total, open, dismissed, acknowledged }
 * - GET /api/risk-findings/:productId returns { findings: [...] }
 *   Each finding has: id, org_id, product_id, scan_id, source, source_id, severity, cvss_score, title, description,
 *     dependency_name, dependency_version, fixed_version, status, created_at, updated_at
 */

import { describe, it, expect } from 'vitest';
import { api, loginTestUser, TEST_USERS } from '../setup/test-helpers.js';
import { TEST_IDS } from '../setup/seed-test-data.js';

describe('/api/risk-findings', () => {
  let mfgToken: string;
  let impToken: string;

  beforeAll(async () => {
    mfgToken = await loginTestUser(TEST_USERS.mfgAdmin);
    impToken = await loginTestUser(TEST_USERS.impAdmin);
  });

  // ─── GET /api/risk-findings/overview ──────────────────────────────────

  describe('GET /api/risk-findings/overview', () => {
    it('should reject unauthenticated request', async () => {
      const res = await api.get('/api/risk-findings/overview');
      expect(res.status).toBe(401);
    });

    it('should reject invalid token', async () => {
      const res = await api.get('/api/risk-findings/overview', { auth: 'invalid.jwt.token' });
      expect(res.status).toBe(401);
    });

    it('should return products array for authenticated user', async () => {
      const res = await api.get('/api/risk-findings/overview', { auth: mfgToken });
      expect(res.status).toBe(200);
      expect(res.body).toHaveProperty('products');
      expect(Array.isArray(res.body.products)).toBe(true);
    });

    it('should include products with findings breakdown', async () => {
      const res = await api.get('/api/risk-findings/overview', { auth: mfgToken });
      expect(res.status).toBe(200);

      // Mfg org has products with seeded vulnerability findings
      expect(res.body.products.length).toBeGreaterThanOrEqual(1);

      const product = res.body.products[0];
      expect(product).toHaveProperty('id');
      expect(product).toHaveProperty('name');
      expect(product).toHaveProperty('findings');
    });

    it('should have severity counts in findings breakdown', async () => {
      const res = await api.get('/api/risk-findings/overview', { auth: mfgToken });
      expect(res.status).toBe(200);

      // Find a product that has seeded findings (e.g. github product)
      const githubProduct = res.body.products.find(
        (p: any) => p.id === TEST_IDS.products.github
      );
      if (githubProduct) {
        const findings = githubProduct.findings;
        expect(findings).toHaveProperty('critical');
        expect(findings).toHaveProperty('high');
        expect(findings).toHaveProperty('medium');
        expect(findings).toHaveProperty('low');
        expect(findings).toHaveProperty('total');
        expect(typeof findings.critical).toBe('number');
        expect(typeof findings.total).toBe('number');
        // Seeded data: 1 critical, 2 high, 1 medium, 1 low = 5 total
        expect(findings.total).toBeGreaterThanOrEqual(1);
      }
    });

    it('should include craCategory on each product', async () => {
      const res = await api.get('/api/risk-findings/overview', { auth: mfgToken });
      expect(res.status).toBe(200);

      for (const product of res.body.products) {
        expect(product).toHaveProperty('craCategory');
      }
    });

    it('should return empty or zero-count products for org with no findings', async () => {
      const emptyToken = await loginTestUser(TEST_USERS.emptyAdmin);
      const res = await api.get('/api/risk-findings/overview', { auth: emptyToken });
      expect(res.status).toBe(200);
      expect(res.body).toHaveProperty('products');
      // Empty org has no products, so products array should be empty
      expect(res.body.products.length).toBe(0);
    });
  });

  // ─── GET /api/risk-findings/:productId ────────────────────────────────

  describe('GET /api/risk-findings/:productId', () => {
    it('should reject unauthenticated request', async () => {
      const res = await api.get(`/api/risk-findings/${TEST_IDS.products.github}`);
      expect(res.status).toBe(401);
    });

    it('should return findings array for a product with vulnerabilities', async () => {
      const res = await api.get(`/api/risk-findings/${TEST_IDS.products.github}`, { auth: mfgToken });
      expect(res.status).toBe(200);
      expect(res.body).toHaveProperty('findings');
      expect(Array.isArray(res.body.findings)).toBe(true);
    });

    it('should include expected fields on each finding', async () => {
      const res = await api.get(`/api/risk-findings/${TEST_IDS.products.github}`, { auth: mfgToken });
      expect(res.status).toBe(200);

      if (res.body.findings.length > 0) {
        const finding = res.body.findings[0];
        expect(finding).toHaveProperty('id');
        expect(finding).toHaveProperty('severity');
        expect(finding).toHaveProperty('title');
        expect(finding).toHaveProperty('source');
        // Check for dependency info (may be snake_case or camelCase)
        const hasDependency = finding.dependency_name || finding.dependencyName;
        expect(hasDependency).toBeTruthy();
      }
    });

    it('should return seeded findings for github product', async () => {
      const res = await api.get(`/api/risk-findings/${TEST_IDS.products.github}`, { auth: mfgToken });
      expect(res.status).toBe(200);

      // Seeded: 5 findings for github product
      expect(res.body.findings.length).toBeGreaterThanOrEqual(1);

      // Check that at least one finding has expected severity
      const severities = res.body.findings.map((f: any) => f.severity);
      const validSeverities = ['critical', 'high', 'medium', 'low'];
      for (const s of severities) {
        expect(validSeverities).toContain(s);
      }
    });

    it('should return empty findings for a product with no vulnerabilities', async () => {
      // gitea product has no seeded vulnerability findings
      const res = await api.get(`/api/risk-findings/${TEST_IDS.products.gitea}`, { auth: mfgToken });
      expect(res.status).toBe(200);
      expect(res.body).toHaveProperty('findings');
      expect(res.body.findings.length).toBe(0);
    });

    it('should return 404 for non-existent product', async () => {
      const res = await api.get('/api/risk-findings/00000000-0000-0000-0000-000000000000', { auth: mfgToken });
      expect([404, 403]).toContain(res.status);
    });
  });

  // ─── Cross-org isolation ──────────────────────────────────────────────

  describe('Cross-org isolation', () => {
    it('should not let importer admin see manufacturer product findings', async () => {
      const res = await api.get(`/api/risk-findings/${TEST_IDS.products.github}`, { auth: impToken });
      expect([403, 404]).toContain(res.status);
    });

    it('should not leak manufacturer products in importer overview', async () => {
      const res = await api.get('/api/risk-findings/overview', { auth: impToken });
      expect(res.status).toBe(200);

      // Importer overview should not contain manufacturer org products
      const mfgProductIds = [
        TEST_IDS.products.github,
        TEST_IDS.products.codeberg,
        TEST_IDS.products.gitea,
        TEST_IDS.products.forgejo,
        TEST_IDS.products.gitlab,
      ];
      const foundCrossOrg = res.body.products.filter(
        (p: any) => mfgProductIds.includes(p.id)
      );
      expect(foundCrossOrg.length).toBe(0);
    });
  });
});
